# Code generated by Microsoft (R) AutoRest Code Generator 0.10.0.0
# Changes may cause incorrect behavior and will be lost if the code is
# regenerated.

module Azure
  #
# StorageAccounts
  #
  class StorageAccounts
    #
    # Creates and initializes a new instance of the StorageAccounts class.
    # @param client service class for accessing basic functionality.
    #
    def initialize(client)
    @client = client
    end

    # @return reference to the StorageManagementClient
    attr_reader :client

            #
            # Checks that account name is valid and is not in use.
            # @param account_name [StorageAccountCheckNameAvailabilityParameters] The name
            # of the storage account within the specified resource group. Storage account
            # names must be between 3 and 24 characters in length and use numbers and
            # lower-case letters only.
            # @return [Concurrent::Promise] Promise object which allows to get HTTP
            # response.
            #
            def check_name_availability(account_name)
              # fail ArgumentError, 'account_name is nil' if account_name.nil?
              account_name.validate unless account_name.nil?

              # Construct URL
              path = "/subscriptions/{subscriptionId}/providers/Microsoft.Storage/checkNameAvailability"
              if (@client.credentials.nil?)
                fail ArgumentError("SubscriptionCloudCredentials are missing from the client.");
              end
              path['{subscriptionId}'] = @client.credentials.subscriptionId
              url = URI.join(@client.base_url, path)
              properties = {}
              properties['api-version'] = CGI.escape(@client.api_version)
              properties.reject!{ |key, value| value.nil? }
              url.query = properties.map{ |key, value| "#{key}=#{CGI.escape(value.to_s)}" }.compact.join('&')

              # Create HTTP transport objects
              http_request = Net::HTTP::Post.new(url.request_uri)

              # Serialize Request
              http_request.add_field('Content-Type', 'application/json')
              if (account_name)
                account_name = Azure::Models::StorageAccountCheckNameAvailabilityParameters.serialize_object(account_name)
              end
              request_content = account_name
              http_request.body = JSON.generate(request_content, quirks_mode: true)

              # Send Request
              promise = Concurrent::Promise.new { @client.make_http_request(http_request, url) }

              promise = promise.then do |http_response|
                status_code = http_response.code.to_i
                response_content = http_response.body
                unless (status_code == 200)
                  error_model = JSON.parse(response_content)
                  fail ClientRuntime::HttpOperationException.new(http_request, http_response, error_model)
                end

                # Create Result
                result = ClientRuntime::HttpOperationResponse.new(http_request, http_response)
                # Deserialize Response
                if status_code == 200
                  begin
                    parsed_response = JSON.load(response_content) unless response_content.to_s.empty?
                    if (parsed_response)
                      parsed_response = Azure::Models::CheckNameAvailabilityResponse.deserialize_object(parsed_response)
                    end
                    result.body = parsed_response
                  rescue Exception => e
                    fail ClientRuntime::DeserializationError.new("Error occured in deserializing the response", e.message, e.backtrace, response_content)
                  end
                end

                result
              end

              promise.execute
            end

            #
            # # Asynchronously creates a new storage account with the specified
            # # parameters. Existing accounts cannot be updated with this API and
            # # should instead use the Update Storage Account API. If an account is
            # # already created and subsequent create request is issued with exact
            # # same set of properties, the request succeeds.The max number of
            # # storage accounts that can be created per subscription is limited to
            # # 20.
              # @param resource_group_name [String] The name of the resource group
              # within the userâ€™s subscription.
              # @param account_name [String] The name of the storage account within
              # the specified resource group. Storage account names must be between 3
              # and 24 characters in length and use numbers and lower-case letters
              # only.
              # @param parameters [StorageAccountCreateParameters] The parameters to
              # provide for the created account.
            # @return [TODO: add type] TODO: add text
            #
            def create(resource_group_name, account_name, parameters)
              # Send request
              response = begin_create(resource_group_name, account_name, parameters).value!
              # Defining polling method.
              get_method = lambda { self.get_properties(resource_group_name, account_name) }
              # Waiting for response.
              return @client.get_put_operation_result(response, get_method)
            end

            #
            # Asynchronously creates a new storage account with the specified parameters.
            # Existing accounts cannot be updated with this API and should instead use
            # the Update Storage Account API. If an account is already created and
            # subsequent create request is issued with exact same set of properties, the
            # request succeeds.The max number of storage accounts that can be created per
            # subscription is limited to 20.
            # @param resource_group_name [String] The name of the resource group within
            # the userâ€™s subscription.
            # @param account_name [String] The name of the storage account within the
            # specified resource group. Storage account names must be between 3 and 24
            # characters in length and use numbers and lower-case letters only.
            # @param parameters [StorageAccountCreateParameters] The parameters to provide
            # for the created account.
            # @return [Concurrent::Promise] Promise object which allows to get HTTP
            # response.
            #
            def begin_create(resource_group_name, account_name, parameters)
              # fail ArgumentError, 'resource_group_name is nil' if resource_group_name.nil?
              # fail ArgumentError, 'account_name is nil' if account_name.nil?
              # fail ArgumentError, 'parameters is nil' if parameters.nil?
              parameters.validate unless parameters.nil?

              # Construct URL
              path = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}"
              if (@client.credentials.nil?)
                fail ArgumentError("SubscriptionCloudCredentials are missing from the client.");
              end
              path['{subscriptionId}'] = @client.credentials.subscriptionId
              path['{resourceGroupName}'] = CGI.escape(resource_group_name)
              path['{accountName}'] = CGI.escape(account_name)
              url = URI.join(@client.base_url, path)
              properties = {}
              properties['api-version'] = CGI.escape(@client.api_version)
              properties.reject!{ |key, value| value.nil? }
              url.query = properties.map{ |key, value| "#{key}=#{CGI.escape(value.to_s)}" }.compact.join('&')

              # Create HTTP transport objects
              http_request = Net::HTTP::Put.new(url.request_uri)

              # Serialize Request
              http_request.add_field('Content-Type', 'application/json')
              if (parameters)
                parameters = Azure::Models::StorageAccountCreateParameters.serialize_object(parameters)
              end
              request_content = parameters
              http_request.body = JSON.generate(request_content, quirks_mode: true)

              # Send Request
              promise = Concurrent::Promise.new { @client.make_http_request(http_request, url) }

              promise = promise.then do |http_response|
                status_code = http_response.code.to_i
                response_content = http_response.body
                unless (status_code == 202 || status_code == 200)
                  error_model = JSON.parse(response_content)
                  fail ClientRuntime::HttpOperationException.new(http_request, http_response, error_model)
                end

                # Create Result
                result = ClientRuntime::HttpOperationResponse.new(http_request, http_response)
                # Deserialize Response
                if status_code == 200
                  begin
                    parsed_response = JSON.load(response_content) unless response_content.to_s.empty?
                    if (parsed_response)
                      parsed_response = Azure::Models::StorageAccount.deserialize_object(parsed_response)
                    end
                    result.body = parsed_response
                  rescue Exception => e
                    fail ClientRuntime::DeserializationError.new("Error occured in deserializing the response", e.message, e.backtrace, response_content)
                  end
                end

                result
              end

              promise.execute
            end

            #
            # Deletes a storage account in Microsoft Azure.
            # @param resource_group_name [String] The name of the resource group within
            # the userâ€™s subscription.
            # @param account_name [String] The name of the storage account within the
            # specified resource group. Storage account names must be between 3 and 24
            # characters in length and use numbers and lower-case letters only.
            # @return [Concurrent::Promise] Promise object which allows to get HTTP
            # response.
            #
            def delete(resource_group_name, account_name)
              # fail ArgumentError, 'resource_group_name is nil' if resource_group_name.nil?
              # fail ArgumentError, 'account_name is nil' if account_name.nil?

              # Construct URL
              path = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}"
              if (@client.credentials.nil?)
                fail ArgumentError("SubscriptionCloudCredentials are missing from the client.");
              end
              path['{subscriptionId}'] = @client.credentials.subscriptionId
              path['{resourceGroupName}'] = CGI.escape(resource_group_name)
              path['{accountName}'] = CGI.escape(account_name)
              url = URI.join(@client.base_url, path)
              properties = {}
              properties['api-version'] = CGI.escape(@client.api_version)
              properties.reject!{ |key, value| value.nil? }
              url.query = properties.map{ |key, value| "#{key}=#{CGI.escape(value.to_s)}" }.compact.join('&')

              # Create HTTP transport objects
              http_request = Net::HTTP::Delete.new(url.request_uri)

              # Send Request
              promise = Concurrent::Promise.new { @client.make_http_request(http_request, url) }

              promise = promise.then do |http_response|
                status_code = http_response.code.to_i
                response_content = http_response.body
                unless (status_code == 200 || status_code == 204)
                  fail ClientRuntime::HttpOperationException.new(http_request, http_response)
                end

                # Create Result
                result = ClientRuntime::HttpOperationResponse.new(http_request, http_response)

                result
              end

              promise.execute
            end

            #
            # Returns the properties for the specified storage account including but not
            # limited to name, account type, location, and account status. The ListKeys
            # operation should be used to retrieve storage keys.
            # @param resource_group_name [String] The name of the resource group within
            # the userâ€™s subscription.
            # @param account_name [String] The name of the storage account within the
            # specified resource group. Storage account names must be between 3 and 24
            # characters in length and use numbers and lower-case letters only.
            # @return [Concurrent::Promise] Promise object which allows to get HTTP
            # response.
            #
            def get_properties(resource_group_name, account_name)
              # fail ArgumentError, 'resource_group_name is nil' if resource_group_name.nil?
              # fail ArgumentError, 'account_name is nil' if account_name.nil?

              # Construct URL
              path = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}"
              if (@client.credentials.nil?)
                fail ArgumentError("SubscriptionCloudCredentials are missing from the client.");
              end
              path['{subscriptionId}'] = @client.credentials.subscriptionId
              path['{resourceGroupName}'] = CGI.escape(resource_group_name)
              path['{accountName}'] = CGI.escape(account_name)
              url = URI.join(@client.base_url, path)
              properties = {}
              properties['api-version'] = CGI.escape(@client.api_version)
              properties.reject!{ |key, value| value.nil? }
              url.query = properties.map{ |key, value| "#{key}=#{CGI.escape(value.to_s)}" }.compact.join('&')

              # Create HTTP transport objects
              http_request = Net::HTTP::Get.new(url.request_uri)

              # Send Request
              promise = Concurrent::Promise.new { @client.make_http_request(http_request, url) }

              promise = promise.then do |http_response|
                status_code = http_response.code.to_i
                response_content = http_response.body
                unless (status_code == 200)
                  error_model = JSON.parse(response_content)
                  fail ClientRuntime::HttpOperationException.new(http_request, http_response, error_model)
                end

                # Create Result
                result = ClientRuntime::HttpOperationResponse.new(http_request, http_response)
                # Deserialize Response
                if status_code == 200
                  begin
                    parsed_response = JSON.load(response_content) unless response_content.to_s.empty?
                    if (parsed_response)
                      parsed_response = Azure::Models::StorageAccount.deserialize_object(parsed_response)
                    end
                    result.body = parsed_response
                  rescue Exception => e
                    fail ClientRuntime::DeserializationError.new("Error occured in deserializing the response", e.message, e.backtrace, response_content)
                  end
                end

                result
              end

              promise.execute
            end

            #
            # Updates the account type or tags for a storage account. It can also be used
            # to add a custom domain (note that custom domains cannot be added via the
            # Create operation). Only one custom domain is supported per storage account.
            # This API can only be used to update one of tags, accountType, or
            # customDomain per call. To update multiple of these properties, call the API
            # multiple times with one change per call. This call does not change the
            # storage keys for the account. If you want to change storage account keys,
            # use the RegenerateKey operation. The location and name of the storage
            # account cannot be changed after creation.
            # @param resource_group_name [String] The name of the resource group within
            # the userâ€™s subscription.
            # @param account_name [String] The name of the storage account within the
            # specified resource group. Storage account names must be between 3 and 24
            # characters in length and use numbers and lower-case letters only.
            # @param parameters [StorageAccountUpdateParameters] The parameters to update
            # on the account. Note that only one property can be changed at a time using
            # this API.
            # @return [Concurrent::Promise] Promise object which allows to get HTTP
            # response.
            #
            def update(resource_group_name, account_name, parameters)
              # fail ArgumentError, 'resource_group_name is nil' if resource_group_name.nil?
              # fail ArgumentError, 'account_name is nil' if account_name.nil?
              # fail ArgumentError, 'parameters is nil' if parameters.nil?
              parameters.validate unless parameters.nil?

              # Construct URL
              path = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}"
              if (@client.credentials.nil?)
                fail ArgumentError("SubscriptionCloudCredentials are missing from the client.");
              end
              path['{subscriptionId}'] = @client.credentials.subscriptionId
              path['{resourceGroupName}'] = CGI.escape(resource_group_name)
              path['{accountName}'] = CGI.escape(account_name)
              url = URI.join(@client.base_url, path)
              properties = {}
              properties['api-version'] = CGI.escape(@client.api_version)
              properties.reject!{ |key, value| value.nil? }
              url.query = properties.map{ |key, value| "#{key}=#{CGI.escape(value.to_s)}" }.compact.join('&')

              # Create HTTP transport objects
              http_request = Net::HTTP::Patch.new(url.request_uri)

              # Serialize Request
              http_request.add_field('Content-Type', 'application/json')
              if (parameters)
                parameters = Azure::Models::StorageAccountUpdateParameters.serialize_object(parameters)
              end
              request_content = parameters
              http_request.body = JSON.generate(request_content, quirks_mode: true)

              # Send Request
              promise = Concurrent::Promise.new { @client.make_http_request(http_request, url) }

              promise = promise.then do |http_response|
                status_code = http_response.code.to_i
                response_content = http_response.body
                unless (status_code == 200)
                  error_model = JSON.parse(response_content)
                  fail ClientRuntime::HttpOperationException.new(http_request, http_response, error_model)
                end

                # Create Result
                result = ClientRuntime::HttpOperationResponse.new(http_request, http_response)
                # Deserialize Response
                if status_code == 200
                  begin
                    parsed_response = JSON.load(response_content) unless response_content.to_s.empty?
                    if (parsed_response)
                      parsed_response = Azure::Models::StorageAccount.deserialize_object(parsed_response)
                    end
                    result.body = parsed_response
                  rescue Exception => e
                    fail ClientRuntime::DeserializationError.new("Error occured in deserializing the response", e.message, e.backtrace, response_content)
                  end
                end

                result
              end

              promise.execute
            end

            #
            # Lists the access keys for the specified storage account.
            # @param resource_group_name [String] The name of the resource group.
            # @param account_name [String] The name of the storage account.
            # @return [Concurrent::Promise] Promise object which allows to get HTTP
            # response.
            #
            def list_keys(resource_group_name, account_name)
              # fail ArgumentError, 'resource_group_name is nil' if resource_group_name.nil?
              # fail ArgumentError, 'account_name is nil' if account_name.nil?

              # Construct URL
              path = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/listKeys"
              if (@client.credentials.nil?)
                fail ArgumentError("SubscriptionCloudCredentials are missing from the client.");
              end
              path['{subscriptionId}'] = @client.credentials.subscriptionId
              path['{resourceGroupName}'] = CGI.escape(resource_group_name)
              path['{accountName}'] = CGI.escape(account_name)
              url = URI.join(@client.base_url, path)
              properties = {}
              properties['api-version'] = CGI.escape(@client.api_version)
              properties.reject!{ |key, value| value.nil? }
              url.query = properties.map{ |key, value| "#{key}=#{CGI.escape(value.to_s)}" }.compact.join('&')

              # Create HTTP transport objects
              http_request = Net::HTTP::Post.new(url.request_uri)

              # Send Request
              promise = Concurrent::Promise.new { @client.make_http_request(http_request, url) }

              promise = promise.then do |http_response|
                status_code = http_response.code.to_i
                response_content = http_response.body
                unless (status_code == 200)
                  error_model = JSON.parse(response_content)
                  fail ClientRuntime::HttpOperationException.new(http_request, http_response, error_model)
                end

                # Create Result
                result = ClientRuntime::HttpOperationResponse.new(http_request, http_response)
                # Deserialize Response
                if status_code == 200
                  begin
                    parsed_response = JSON.load(response_content) unless response_content.to_s.empty?
                    if (parsed_response)
                      parsed_response = Azure::Models::StorageAccountKeys.deserialize_object(parsed_response)
                    end
                    result.body = parsed_response
                  rescue Exception => e
                    fail ClientRuntime::DeserializationError.new("Error occured in deserializing the response", e.message, e.backtrace, response_content)
                  end
                end

                result
              end

              promise.execute
            end

            #
            # Lists all the storage accounts available under the subscription. Note that
            # storage keys are not returned; use the ListKeys operation for this.
            # @return [Concurrent::Promise] Promise object which allows to get HTTP
            # response.
            #
            def list()
              # Construct URL
              path = "/subscriptions/{subscriptionId}/providers/Microsoft.Storage/storageAccounts"
              if (@client.credentials.nil?)
                fail ArgumentError("SubscriptionCloudCredentials are missing from the client.");
              end
              path['{subscriptionId}'] = @client.credentials.subscriptionId
              url = URI.join(@client.base_url, path)
              properties = {}
              properties['api-version'] = CGI.escape(@client.api_version)
              properties.reject!{ |key, value| value.nil? }
              url.query = properties.map{ |key, value| "#{key}=#{CGI.escape(value.to_s)}" }.compact.join('&')

              # Create HTTP transport objects
              http_request = Net::HTTP::Get.new(url.request_uri)

              # Send Request
              promise = Concurrent::Promise.new { @client.make_http_request(http_request, url) }

              promise = promise.then do |http_response|
                status_code = http_response.code.to_i
                response_content = http_response.body
                unless (status_code == 200)
                  error_model = JSON.parse(response_content)
                  fail ClientRuntime::HttpOperationException.new(http_request, http_response, error_model)
                end

                # Create Result
                result = ClientRuntime::HttpOperationResponse.new(http_request, http_response)
                # Deserialize Response
                if status_code == 200
                  begin
                    parsed_response = JSON.load(response_content) unless response_content.to_s.empty?
                    if (parsed_response)
                      parsed_response = Azure::Models::StorageAccountListResponse.deserialize_object(parsed_response)
                    end
                    result.body = parsed_response
                  rescue Exception => e
                    fail ClientRuntime::DeserializationError.new("Error occured in deserializing the response", e.message, e.backtrace, response_content)
                  end
                end

                result
              end

              promise.execute
            end

            #
            # Lists all the storage accounts available under the given resource group.
            # Note that storage keys are not returned; use the ListKeys operation for
            # this.
            # @param resource_group_name [String] The name of the resource group within
            # the userâ€™s subscription.
            # @return [Concurrent::Promise] Promise object which allows to get HTTP
            # response.
            #
            def list_by_resource_group(resource_group_name)
              # fail ArgumentError, 'resource_group_name is nil' if resource_group_name.nil?

              # Construct URL
              path = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts"
              if (@client.credentials.nil?)
                fail ArgumentError("SubscriptionCloudCredentials are missing from the client.");
              end
              path['{subscriptionId}'] = @client.credentials.subscriptionId
              path['{resourceGroupName}'] = CGI.escape(resource_group_name)
              url = URI.join(@client.base_url, path)
              properties = {}
              properties['api-version'] = CGI.escape(@client.api_version)
              properties.reject!{ |key, value| value.nil? }
              url.query = properties.map{ |key, value| "#{key}=#{CGI.escape(value.to_s)}" }.compact.join('&')

              # Create HTTP transport objects
              http_request = Net::HTTP::Get.new(url.request_uri)

              # Send Request
              promise = Concurrent::Promise.new { @client.make_http_request(http_request, url) }

              promise = promise.then do |http_response|
                status_code = http_response.code.to_i
                response_content = http_response.body
                unless (status_code == 200)
                  error_model = JSON.parse(response_content)
                  fail ClientRuntime::HttpOperationException.new(http_request, http_response, error_model)
                end

                # Create Result
                result = ClientRuntime::HttpOperationResponse.new(http_request, http_response)
                # Deserialize Response
                if status_code == 200
                  begin
                    parsed_response = JSON.load(response_content) unless response_content.to_s.empty?
                    if (parsed_response)
                      parsed_response = Azure::Models::StorageAccountListResponse.deserialize_object(parsed_response)
                    end
                    result.body = parsed_response
                  rescue Exception => e
                    fail ClientRuntime::DeserializationError.new("Error occured in deserializing the response", e.message, e.backtrace, response_content)
                  end
                end

                result
              end

              promise.execute
            end

            #
            # Regenerates the access keys for the specified storage account.
            # @param resource_group_name [String] The name of the resource group within
            # the userâ€™s subscription.
            # @param account_name [String] The name of the storage account within the
            # specified resource group. Storage account names must be between 3 and 24
            # characters in length and use numbers and lower-case letters only.
            # @param regenerate_key [StorageAccountRegenerateKeyParameters] Specifies name
            # of the key which should be regenerated.
            # @return [Concurrent::Promise] Promise object which allows to get HTTP
            # response.
            #
            def regenerate_key(resource_group_name, account_name, regenerate_key)
              # fail ArgumentError, 'resource_group_name is nil' if resource_group_name.nil?
              # fail ArgumentError, 'account_name is nil' if account_name.nil?
              # fail ArgumentError, 'regenerate_key is nil' if regenerate_key.nil?
              regenerate_key.validate unless regenerate_key.nil?

              # Construct URL
              path = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/regenerateKey"
              if (@client.credentials.nil?)
                fail ArgumentError("SubscriptionCloudCredentials are missing from the client.");
              end
              path['{subscriptionId}'] = @client.credentials.subscriptionId
              path['{resourceGroupName}'] = CGI.escape(resource_group_name)
              path['{accountName}'] = CGI.escape(account_name)
              url = URI.join(@client.base_url, path)
              properties = {}
              properties['api-version'] = CGI.escape(@client.api_version)
              properties.reject!{ |key, value| value.nil? }
              url.query = properties.map{ |key, value| "#{key}=#{CGI.escape(value.to_s)}" }.compact.join('&')

              # Create HTTP transport objects
              http_request = Net::HTTP::Post.new(url.request_uri)

              # Serialize Request
              http_request.add_field('Content-Type', 'application/json')
              if (regenerate_key)
                regenerate_key = Azure::Models::StorageAccountRegenerateKeyParameters.serialize_object(regenerate_key)
              end
              request_content = regenerate_key
              http_request.body = JSON.generate(request_content, quirks_mode: true)

              # Send Request
              promise = Concurrent::Promise.new { @client.make_http_request(http_request, url) }

              promise = promise.then do |http_response|
                status_code = http_response.code.to_i
                response_content = http_response.body
                unless (status_code == 200)
                  error_model = JSON.parse(response_content)
                  fail ClientRuntime::HttpOperationException.new(http_request, http_response, error_model)
                end

                # Create Result
                result = ClientRuntime::HttpOperationResponse.new(http_request, http_response)
                # Deserialize Response
                if status_code == 200
                  begin
                    parsed_response = JSON.load(response_content) unless response_content.to_s.empty?
                    if (parsed_response)
                      parsed_response = Azure::Models::StorageAccountKeys.deserialize_object(parsed_response)
                    end
                    result.body = parsed_response
                  rescue Exception => e
                    fail ClientRuntime::DeserializationError.new("Error occured in deserializing the response", e.message, e.backtrace, response_content)
                  end
                end

                result
              end

              promise.execute
            end

            #
            # Lists all the storage accounts available under the subscription. Note that
            # storage keys are not returned; use the ListKeys operation for this.
            # @param next_link [String] NextLink from the previous successful call to List
            # operation.
            # @return [Concurrent::Promise] Promise object which allows to get HTTP
            # response.
            #
            def list_next(next_link)
              # fail ArgumentError, 'next_link is nil' if next_link.nil?

              # Construct URL
              path = "{nextLink}"
              path['{nextLink}'] = CGI.escape(next_link)
              properties = {}
              properties.reject!{ |key, value| value.nil? }
              url.query = properties.map{ |key, value| "#{key}=#{CGI.escape(value.to_s)}" }.compact.join('&')

              # Create HTTP transport objects
              http_request = Net::HTTP::Get.new(url.request_uri)

              # Send Request
              promise = Concurrent::Promise.new { @client.make_http_request(http_request, url) }

              promise = promise.then do |http_response|
                status_code = http_response.code.to_i
                response_content = http_response.body
                unless (status_code == 200)
                  error_model = JSON.parse(response_content)
                  fail ClientRuntime::HttpOperationException.new(http_request, http_response, error_model)
                end

                # Create Result
                result = ClientRuntime::HttpOperationResponse.new(http_request, http_response)
                # Deserialize Response
                if status_code == 200
                  begin
                    parsed_response = JSON.load(response_content) unless response_content.to_s.empty?
                    if (parsed_response)
                      parsed_response = Azure::Models::StorageAccountListResponse.deserialize_object(parsed_response)
                    end
                    result.body = parsed_response
                  rescue Exception => e
                    fail ClientRuntime::DeserializationError.new("Error occured in deserializing the response", e.message, e.backtrace, response_content)
                  end
                end

                result
              end

              promise.execute
            end

            #
            # Lists all the storage accounts available under the given resource group.
            # Note that storage keys are not returned; use the ListKeys operation for
            # this.
            # @param next_link [String] NextLink from the previous successful call to List
            # operation.
            # @return [Concurrent::Promise] Promise object which allows to get HTTP
            # response.
            #
            def list_by_resource_group_next(next_link)
              # fail ArgumentError, 'next_link is nil' if next_link.nil?

              # Construct URL
              path = "{nextLink}"
              path['{nextLink}'] = CGI.escape(next_link)
              properties = {}
              properties.reject!{ |key, value| value.nil? }
              url.query = properties.map{ |key, value| "#{key}=#{CGI.escape(value.to_s)}" }.compact.join('&')

              # Create HTTP transport objects
              http_request = Net::HTTP::Get.new(url.request_uri)

              # Send Request
              promise = Concurrent::Promise.new { @client.make_http_request(http_request, url) }

              promise = promise.then do |http_response|
                status_code = http_response.code.to_i
                response_content = http_response.body
                unless (status_code == 200)
                  error_model = JSON.parse(response_content)
                  fail ClientRuntime::HttpOperationException.new(http_request, http_response, error_model)
                end

                # Create Result
                result = ClientRuntime::HttpOperationResponse.new(http_request, http_response)
                # Deserialize Response
                if status_code == 200
                  begin
                    parsed_response = JSON.load(response_content) unless response_content.to_s.empty?
                    if (parsed_response)
                      parsed_response = Azure::Models::StorageAccountListResponse.deserialize_object(parsed_response)
                    end
                    result.body = parsed_response
                  rescue Exception => e
                    fail ClientRuntime::DeserializationError.new("Error occured in deserializing the response", e.message, e.backtrace, response_content)
                  end
                end

                result
              end

              promise.execute
            end

    end
    end
